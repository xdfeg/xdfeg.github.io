<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/09/03/%E5%8E%9F%E5%9E%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E8%A7%84%E5%88%99/"/>
      <url>/2022/09/03/%E5%8E%9F%E5%9E%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>title: </p><ol><li><p>所有的引用类型（数组，对象，函数），都具有对象的特性，可以自由扩展属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> obj = &#123;&#125;  //obj<span class="selector-class">.a</span> = <span class="number">1</span></span><br><span class="line"><span class="selector-tag">var</span> arr = <span class="selector-attr">[]</span>  //obj<span class="selector-class">.b</span> = <span class="number">2</span></span><br><span class="line"><span class="selector-tag">var</span> fn = function()&#123;&#125;  //obj<span class="selector-class">.c</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>所有的对象，都有__proto__属性（隐式原型），属性值是一个普通对象</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// __proto__也叫隐式原型 ==&gt;  <span class="selector-attr">[[prototype]</span>]</span><br><span class="line">console<span class="selector-class">.log</span>(obj.__proto__)   //<span class="selector-attr">[[Prototype]</span>]: Object</span><br><span class="line">console.<span class="built_in">log</span>(arr.__proto__)   //[[Prototype]]: <span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">console.<span class="built_in">log</span>(fn.__proto__)    //[[Prototype]]: ƒn ()</span><br></pre></td></tr></table></figure></li><li><p>所有的函数，都有一个prototype属性（显示原型），属性值也是一个普通对象</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// prototype 也叫显示原型</span><br><span class="line">console<span class="selector-class">.log</span>(fn<span class="selector-class">.prototype</span>)</span><br></pre></td></tr></table></figure></li><li><p>所有对象的隐式原型（<strong>proto</strong>) 指向它的构造函数的显示原型（prototype）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === <span class="selector-tag">Object</span><span class="selector-class">.prototype</span>   //true  <span class="selector-tag">Object</span>是对象的构造函数  <span class="selector-tag">var</span> obj = new <span class="selector-tag">Object</span>()</span><br><span class="line">arr.__proto__ === Array<span class="selector-class">.prototype</span>    //true  Array是数组的构造函数  <span class="selector-tag">var</span> arr = new Array() </span><br><span class="line">fn.__proto__  === Function<span class="selector-class">.prototype</span>  //true </span><br></pre></td></tr></table></figure></li><li><p>当试图得到一个对象的属性时，如果这个对象本身并没有这个属性，那么会去他的隐式原型（<strong>proto</strong>)中找 （最终也是在构造函数的prototype中去寻找）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Star(name , age)&#123;</span><br><span class="line">    this<span class="selector-class">.name</span> = name,</span><br><span class="line">    this<span class="selector-class">.age</span> = age</span><br><span class="line">&#125;</span><br><span class="line">//给构造函数的prototype（显示原型）添加一个sex属性</span><br><span class="line">// 在原型对象上添加了一个sex属性</span><br><span class="line">Star<span class="selector-class">.prototype</span><span class="selector-class">.sex</span> = &#x27;male&#x27;</span><br><span class="line">// 因为隐式原型指向构造函数的显示原型 即 ldh.__proto__ === Star<span class="selector-class">.prototype</span></span><br><span class="line">// 实例找不到sex属性，就会去构造函数的显示原型中查找</span><br><span class="line"><span class="selector-tag">var</span> ldh = new Star(&#x27;刘德华&#x27;, <span class="number">18</span>)</span><br><span class="line">console<span class="selector-class">.log</span>(ldh<span class="selector-class">.sex</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29141544/1656939735768-8ab9cd5c-e228-4d1b-8e5a-9f21786ebd4a.png#clientId=u8b65e94e-62c4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=ue679edbd&margin=%5Bobject%20Object%5D&name=da5ed28b07a3bb119c7d05de795a36c.png&originHeight=334&originWidth=870&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27318&status=done&style=none&taskId=ufe7b257d-70b3-4a3c-ab2e-4d67b740bc8&title=&width=580" alt="da5ed28b07a3bb119c7d05de795a36c.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/29141544/1656939736198-8861e6bc-c65e-4b9b-a048-56f34efe5792.png#clientId=u8b65e94e-62c4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=457&id=ufb25768d&margin=%5Bobject%20Object%5D&name=%E5%8E%9F%E5%9E%8B.png&originHeight=686&originWidth=1744&originalType=binary&ratio=1&rotation=0&showTitle=false&size=161074&status=done&style=none&taskId=u715b8406-be55-44ef-a00b-4420e595e9b&title=&width=1162.6666666666667" alt="原型.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/29141544/1656939736898-28ecc4e8-6fb4-442c-b528-a5dd193d79f7.png#clientId=u8b65e94e-62c4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=509&id=ue148ddbb&margin=%5Bobject%20Object%5D&name=a7b9ecf0e8c0180f7bbd01c9269629c.png&originHeight=764&originWidth=1403&originalType=binary&ratio=1&rotation=0&showTitle=false&size=347836&status=done&style=none&taskId=u7bf148f1-2fa7-4c29-9df3-bf0010560c0&title=&width=935.3333333333334" alt="a7b9ecf0e8c0180f7bbd01c9269629c.png"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/03/%E6%89%8B%E6%92%95JS%E7%B3%BB%E5%88%97/"/>
      <url>/2022/09/03/%E6%89%8B%E6%92%95JS%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>title: <br>Tags: JS</p><p><a name="2948440a"></a></p><h1 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">src</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (!src | !(src <span class="keyword">instanceof</span> <span class="title class_">Object</span>) | (<span class="keyword">typeof</span> src === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> src || <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> constructor = src.<span class="property">constructor</span></span><br><span class="line">  <span class="keyword">var</span> dst = <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      dst[key] = <span class="title function_">deepCopy</span>(src[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="f77dad25"></a></p><h1 id="实现一个ajax"><a href="#实现一个ajax" class="headerlink" title="实现一个ajax"></a>实现一个ajax</h1><p>ajax实现<strong>局部刷新</strong>的原理是通过XmlHttpRequest对象来向服务器发送异步请求，通过js操作相应的DOM来更新页面</p><p>ajax实现过程：</p><ol><li>创建XmlHttpRequest对象</li><li>初始化参数</li><li>发送信息</li><li>接收信息</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) &#123; <span class="comment">// 4表示响应信息已经全部接收</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123; <span class="comment">// status 从服务器返回的状态码</span></span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">reposeText</span>); <span class="comment">// reposeText 从服务器返回数据的字符串格式</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));<span class="comment">// statusText 伴随状态码返回的信息，如status=200时，statusText=&#x27;OK&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();<span class="comment">// 创建XMLHttpRequest对象</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);<span class="comment">// 初始化http的请求参数，但是不发送请求</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = handler;<span class="comment">// 状态改变触发的回调函数 接收请求</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);<span class="comment">// 给一个打开但是未发送的请求设置参数</span></span><br><span class="line">    xhr.<span class="title function_">send</span>();<span class="comment">// 发送http请求</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="2b86a976"></a></p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p><strong>set去重：</strong></p><p>缺点：对象无法去重</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br></pre></td></tr></table></figure><p><strong>indexOf去重：</strong></p><p>缺点：NaN和对象不能去重</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(result.<span class="title function_">indexOf</span>(val) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1,&#123;&#125;,&#123;&#125;,NaN,NaN,null,null,undefined,undefined,&#x27;ss&#x27;,&#x27;ss&#x27;].unique();</span></span><br></pre></td></tr></table></figure><p><strong>includes去重：</strong></p><p>缺点：对象不能去重</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> resultArr = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resultArr.<span class="title function_">includes</span>(item)) &#123;</span><br><span class="line">            resultArr.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> resultArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>splice去重：</p><p>缺点：NaN和对象不能去重，null直接消失了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">                arr.<span class="title function_">splice</span>(j,<span class="number">1</span>);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasOwnProperty去重：</p><p>缺点：无，全部去重了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> obj.<span class="title function_">hasOwnProperty</span>(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>filter去重：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item, index, arr</span>) &#123;</span><br><span class="line">    <span class="comment">//当前元素，在原始数组中的第一个索引===当前索引值，否则返回当前元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>map去重：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> resultArr = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.<span class="title function_">has</span>(item)) &#123;</span><br><span class="line">            resultArr.<span class="title function_">push</span>(item);</span><br><span class="line">            map.<span class="title function_">set</span>(item,<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> resultArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reduce+includes去重：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unique3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev.<span class="title function_">includes</span>(cur) ? prev : [...prev,cur], []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="120e5fa4"></a></p><h1 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h1><p><strong>方法一：Array.prototype.flat()</strong></p><ul><li><code>Array.prototype.flat()</code> 特性总结： <ul><li><code>Array.prototype.flat()</code> 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</li><li>不传参数时，默认“拉平”一层，可以传入一个整数，表示想要“拉平”的层数。</li><li>传入 <code>&lt;=0</code> 的整数将返回原数组，不“拉平”</li><li><code>Infinity</code> 关键字作为参数时，无论多少层嵌套，都会转为一维数组</li><li>如果原数组有空位，<code>Array.prototype.flat()</code> 会跳过空位。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>],[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]]], <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>));</span><br><span class="line"><span class="comment">/* [1,  2,  2, 3,  4,  5,  5,  6,  7,  8, 9, 11, 12, 12, 13, 14, 10] */</span></span><br></pre></td></tr></table></figure><p><strong>方法二：转换为字符串，再把字符串对象用“，”转换成数组</strong></p><ul><li><p>思路：可以先把多维数组先转换为字符串，再基于”,”分隔符将字符串对象分割成字符串数组 </p></li><li><p><code>toString()</code> 扁平化数组： </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>],[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]]], <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">arr = arr.<span class="title function_">toString</span>();</span><br><span class="line"><span class="comment">// &quot;1,2,2,3,4,5,5,6,7,8,9,11,12,12,13,14,10&quot;</span></span><br><span class="line"></span><br><span class="line">arr = arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;11&quot;, &quot;12&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;10&quot;]</span></span><br><span class="line"></span><br><span class="line">arr = arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseFloat</span>(item));</span><br><span class="line"><span class="comment">// [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]</span></span><br></pre></td></tr></table></figure></li><li><p><code>JSON.stringify()</code>扁平化数组： </p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>],[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]]], <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">arr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr);</span><br><span class="line"><span class="comment">// &quot;[[1,2,2],[3,4,5,5],[6,7,8,9,[11,12,[12,13,[14]]]],10]&quot;</span></span><br><span class="line"></span><br><span class="line">arr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr).<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;1,2,2,3,4,5,5,6,7,8,9,11,12,12,13,14,10&quot;</span></span><br><span class="line"></span><br><span class="line">arr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr).<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">parseFloat</span>(item));</span><br><span class="line"><span class="comment">// [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>方法三：循环验证是否为数组</strong></p><ul><li>基于数组的<code>some</code>方法，只要数组里面有一项元素是数组就继续循环，扁平数组</li><li>核心：<code>[].concat(...arr)</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>],[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]]], <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line"> arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]</span></span><br></pre></td></tr></table></figure><p><strong>方法四：</strong><code>**forEach**</code><strong>+</strong><code>**isArray**</code><strong>+</strong><code>**push**</code><strong>+</strong><code>**recursivity**</code></p><ul><li>相当于：自己实现一个 <code>flat</code> 扁平化</li><li>实现思路： <ul><li>循环数组里的每一个元素</li><li>判断该元素是否为数组 <ul><li>是数组的话，继续循环遍历这个元素——数组</li><li>不是数组的话，把元素添加到新的数组中</li></ul></li></ul></li><li>实现流程： <ol><li>创建一个空数组，用来保存遍历到的非数组元素</li><li>创建一个循环遍历数组的函数，cycleArray</li><li>取得数组中的每一项，验证<code>Array.isArray()</code> <ul><li>数组的话，继续循环</li><li>非数组的话，添加到新数组中</li></ul></li><li>返回新数组对象</li></ol></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>],[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]]], <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">// forEach 遍历数组会自动跳过空元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">eachFlat</span> = (<span class="params">arr = [], depth = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []; <span class="comment">// 缓存递归结果</span></span><br><span class="line">  <span class="comment">// 开始递归</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="comment">// forEach 会自动去除数组空位</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 控制递归深度</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归数组</span></span><br><span class="line">        <span class="title function_">flat</span>(item, depth - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存元素</span></span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(arr, depth)</span><br><span class="line">  <span class="comment">// 返回递归结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">eachFlat</span>(arr)); <span class="comment">// [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="comment">// for of 循环不能去除数组空位，需要手动去除</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">forFlat</span> = (<span class="params">arr = [], depth = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">flat</span>(item, depth - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 去除空元素，添加非undefined元素</span></span><br><span class="line">        item !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; result.<span class="title function_">push</span>(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(arr, depth)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">forFlat</span>(arr)); <span class="comment">// [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10]</span></span><br></pre></td></tr></table></figure><p><strong>方法五：</strong><code>**reduce**</code>**+ <strong><code>**concat**</code></strong>+ <strong><code>**isArray**</code></strong>+ **<code>**recursivity**</code></p><ul><li>相当于：自己实现一个 <code>flat</code> 扁平化</li><li>思路与方法四相同</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能展开一层（可忽略不看）：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>, <span class="number">23</span>, [<span class="number">34</span>, <span class="number">56</span>, [<span class="number">78</span>, <span class="number">90</span>, <span class="number">100</span>, [<span class="number">110</span>, <span class="number">120</span>, <span class="number">130</span>, <span class="number">140</span>]]]];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">myFlat</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(cur);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myFlat</span>(arr));<span class="comment">// [ 12, 23, 34, 56, [ 78, 90, 100, [ 110, 120, 130, 140 ] ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可控制深度的直接全员扁平化（也就那样）：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">myFlat</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">myFlat</span>(cur) : cur);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myFlat</span>(arr));<span class="comment">// [12, 23, 34, 56, 78, 90, 100, 110, 120, 130, 140]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可控制展开深度的扁平化（最优）:</span></span><br><span class="line"><span class="comment">// 使用 reduce、concat 和递归展开无限多层嵌套的数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatDeep</span>(<span class="params">arr, d = <span class="number">1</span></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> d &gt; <span class="number">0</span> ? arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) ? <span class="title function_">flatDeep</span>(val, d - <span class="number">1</span>) : val), [])</span><br><span class="line">                : arr.<span class="title function_">slice</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">flatDeep</span>(arr, <span class="title class_">Infinity</span>);<span class="comment">// [12, 23, 34, 56, 78, 90, 100, 110, 120, 130, 140]</span></span><br></pre></td></tr></table></figure><p><strong>方法六：使用栈的思想实现flat函数</strong></p><ul><li>栈思想： 后进先出的数据结构</li><li>实现思路： <ul><li>不断获取并删除栈中最后一个元素A，判断A是否为数组元素，直到栈内元素为空，全部添加到<code>newArr</code> <ul><li>是数组，则<code>push</code>到栈中，继续循环栈内元素，直到栈为空</li><li>不是数组，则<code>unshift</code>添加到<code>newArr</code>中</li></ul></li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无递归数组扁平化，使用堆栈</span></span><br><span class="line"><span class="comment">// 注意：深度的控制比较低效，因为需要检查每一个值的深度</span></span><br><span class="line"><span class="comment">// 也可能在 shift / unshift 上进行 w/o 反转，但是末端的数组 OPs 更快</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">input</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...input]; <span class="comment">// 将数组元素拷贝至栈，直接赋值会改变原数组</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"><span class="comment">//如果栈不为空，则循环遍历</span></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = stack.<span class="title function_">pop</span>(); <span class="comment">// 删除数组最后一个元素，并获取它</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next)) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(...next);  <span class="comment">// 如果是数组再次入栈，并且展开了一层</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">unshift</span>(next); <span class="comment">// 如果不是数组就将其取出来放入结果数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>, <span class="number">23</span>, [<span class="number">34</span>, <span class="number">56</span>, [<span class="number">78</span>, <span class="number">90</span>, <span class="number">100</span>, [<span class="number">110</span>, <span class="number">120</span>, <span class="number">130</span>, <span class="number">140</span>]]]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br><span class="line"><span class="comment">// [12, 23, 34, 56, 78, 90, 100, 110, 120, 130, 140]</span></span><br></pre></td></tr></table></figure><p><strong>方法七：Use Generator function</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">flatten</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="keyword">yield</span>* <span class="title function_">flatten</span>(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"><span class="keyword">const</span> flattened = [...<span class="title function_">flatten</span>(arr)]; <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><a name="b05634b3"></a></p><h1 id="休眠函数"><a href="#休眠函数" class="headerlink" title="休眠函数"></a>休眠函数</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span> (time) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">500</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里写sleep之后需要去做的事情</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Do some thing, &#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Do other things, &#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><a name="821a2b1f"></a></p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><strong>普通递归：</strong></p><p>会出现浏览器假死现象，毕竟递归需要堆栈，数字过大内存不够。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">2</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化递归:</strong></p><p>把前两位数字做成参数避免重复计算</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n, v1, v2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> v1;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> v2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>, v2, v1 + v2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fib</span>(n, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化递归：</strong></p><p>利用闭包特性把运算结果存储在数组里，避免重复计算</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> memo = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">fib</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[n] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            memo[n] = <span class="title function_">fib</span>(n - <span class="number">2</span>) + <span class="title function_">fib</span>(n - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p><strong>for循环：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">1</span>,</span><br><span class="line">        n2 = <span class="number">1</span>,</span><br><span class="line">        sum = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        sum = n1 + n2</span><br><span class="line">        n1 = n2</span><br><span class="line">        n2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for循环+解构赋值：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">1</span>; n2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        [n1, n2] = [n2, n1 + n2]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="6ed00e55"></a></p><h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><p><a name="060aa7df"></a></p><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> middle = arr.<span class="title function_">shift</span>() || <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> left = [], right = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; middle) &#123;</span><br><span class="line">            left.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; middle) &#123;</span><br><span class="line">            right.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>(middle, <span class="title function_">quickSort</span>(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="042772f2"></a></p><h1 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr: <span class="built_in">Array</span>&lt;number&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>, len=arr.<span class="property">length</span>; i&lt;len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j &lt; len-i-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="f62c909b"></a></p><h1 id="手动控制并发请求"><a href="#手动控制并发请求" class="headerlink" title="手动控制并发请求"></a>手动控制并发请求</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ……</span></span><br></pre></td></tr></table></figure><p><a name="10054771"></a></p><h1 id="debounce防抖"><a href="#debounce防抖" class="headerlink" title="debounce防抖"></a>debounce防抖</h1><p>防抖：</p><p>在事件被触发后不马上执行回调，n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p><p>如果再次执行，就清空之前的定时器，重新加定时器</p><p>强调执行最后一次</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>(...args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="c4386f01"></a></p><h1 id="throttle节流"><a href="#throttle节流" class="headerlink" title="throttle节流"></a>throttle节流</h1><p>节流：强调一段固定的时间内只触发一次回调函数</p><p>定时器版本：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">fn</span>(...args);</span><br><span class="line">            timer = <span class="literal">null</span>; <span class="comment">// 只有触发了函数，timer为null,下一次才能再次执行这个定时器</span></span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间戳版本：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="comment">// if (typeof fn !== &#x27;function&#x27;) &#123;</span></span><br><span class="line">    <span class="comment">//     throw new TypeError(&#x27;need a function!&#x27;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; delay) &#123;</span><br><span class="line">            <span class="title function_">fn</span>(...args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="call"></a></p><h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>详细原理可以看<a href="https://www.notion.so/this-call-apply-bind-5a2c3aff430d4fc29f628d319e79a284">this指向与call,apply,bind</a></p><p><code>xFn.call(xObj,x1,x2,……)</code></p><p>上面调用相当于给xObj添加一个xFn方法并把参数x1,x2……传进去执行，以下实现也是按照此逻辑</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line"><span class="comment">// context就是call的第一个参数 xObj</span></span><br><span class="line">    <span class="comment">// 如果没有传或传的值为空对象 context指向window</span></span><br><span class="line">    context = context || <span class="variable language_">window</span>;</span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span> <span class="comment">//给context添加一个方法 指向this this就是我们调用call的那个函数xFn</span></span><br><span class="line">    <span class="comment">// 处理参数 将content后面的参数取出来</span></span><br><span class="line">    <span class="keyword">let</span> arg = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>) <span class="comment">//[...xxx]把类数组变成数组，arguments为啥不是数组自行搜索 slice返回一个新数组</span></span><br><span class="line">    <span class="keyword">let</span> result = context.<span class="title function_">fn</span>(...arg) <span class="comment">//执行fn</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span> <span class="comment">//删除方法</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="apply"></a></p><h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><p>与call的区别是 参数是数组或类数组的对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> context = context || <span class="variable language_">window</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 需要判断是否存储第二个参数</span></span><br><span class="line">  <span class="comment">// 如果存在，就将第二个参数展开</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bind"></a></p><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>与call和apply的区别是 bind返回的是新函数 不会立即执行</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> context = context || <span class="variable language_">window</span>;</span><br><span class="line"><span class="comment">//同样因为支持柯里化形式传参我们需要再次获取存储参数</span></span><br><span class="line">      <span class="keyword">let</span> newArgs = args.<span class="title function_">concat</span>([...<span class="variable language_">arguments</span>]);</span><br><span class="line">      context.<span class="property">fn</span> = _this;</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line">      <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>(...newArgs)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.<span class="title function_">fn</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="instanceof"></a></p><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>a instanceof Object</code></p><p>判断<code>Object</code>的prototype是否在<code>a</code>的原型链上。</p><p>原型链图解可参考：<a href="https://www.notion.so/8408f46770754943af25e666caeee0cc">原型相关</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">target, origin</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> proto = target.<span class="property">__proto__</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">      <span class="keyword">if</span> (origin.<span class="property"><span class="keyword">prototype</span></span> === proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">myInstanceof</span>(proto, origin);<span class="comment">//继续沿着原型链网上找</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Object的_proto_指向null(原型链的尽头)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a name="d0a6c93f"></a></p><h1 id="实现柯里化函数"><a href="#实现柯里化函数" class="headerlink" title="实现柯里化函数"></a>实现柯里化函数</h1><p>柯里化是一种函数的转换，它是指将一个函数从可调用的 <code>f(a, b, c)</code>转换为可调用的 <code>f(a)(b)(c)</code>。柯里化不会调用函数。它只是对函数进行转换。</p><p>具体原理可见：<a href="https://www.notion.so/078e8164833046fb9867e9fd201c5391">函数柯里化</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurry</span>(<span class="params">func</span>) &#123;</span><br><span class="line"><span class="comment">// func 是要转换的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line"><span class="comment">// func.length是原函数的形参数量</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= func.<span class="property">length</span>) &#123; <span class="comment">// 实际传进来的参数数量&gt;=原函数形参数量，才直接执行</span></span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(args2)); <span class="comment">// 传的参数不够时，就连着之前传的参数一起继续柯里化</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myCurry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> <span class="title function_">currying</span>(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>扩展题：</p><p>实现一个add方法，使计算结果能够满足如下预期：</p><p><code>add(1)(2)(3) = 6</code></p><p><code>add(1, 2, 3)(4) = 10</code></p><p><code>add(1)(2)(3)(4)(5) = 15</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> _args.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    [].<span class="property">push</span>.<span class="title function_">apply</span>(_args, [...<span class="variable language_">arguments</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">5</span>)()</span><br></pre></td></tr></table></figure><p><a name="d54a6e8e"></a></p><h1 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h1><p>compose函数可以将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。右边的方法最开始执行，然后往左边返回（<strong>从右往左</strong>）</p><p>详情可见：<a href="https://juejin.cn/post/6844904061821517832">https://juejin.cn/post/6844904061821517832</a></p><p>让<code>compose(multiply, add)(10)</code>等价于：<code>multiply(add(10));</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myCompose</span> = (<span class="params">...args</span>) =&gt; <span class="function"><span class="params">x</span> =&gt;</span> args.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">res, cb</span>) =&gt;</span> <span class="title function_">cb</span>(res), x);</span><br></pre></td></tr></table></figure><p><a name="e9cff246"></a></p><h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a><strong>pipe</strong></h1><p>跟<code>compose</code>函数的作用是一样的，也是将参数平铺，只不过他的顺序是<strong>从左往右</strong></p><p>让<code>pipe(add, multiply)(10)</code>等价于：<code>multiply(add(10));</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myPipe</span> = (<span class="params">...args</span>) =&gt; <span class="function"><span class="params">x</span> =&gt;</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res, cb</span>) =&gt;</span> <span class="title function_">cb</span>(res), x)</span><br></pre></td></tr></table></figure><p><a name="9cdd24ee"></a></p><h1 id="实现new"><a href="#实现new" class="headerlink" title="实现new"></a>实现new</h1><p>new干了什么：</p><ol><li>帮我们创建一个空对象；</li><li>将新对象的原型（prototype）指向构造函数的原型（prototype）；</li><li>执行构造函数，把构造函数的属性添加到新对象；</li><li>返回创建的新对象；</li></ol><p>详情：<a href="https://juejin.cn/post/6844904153718718472">https://juejin.cn/post/6844904153718718472</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">func, ...rest</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建空对象，并将新对象的__proto__属性指向构造函数的prototype，func是构造函数</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(func.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="comment">// 执行构造函数，改变构造函数的this指针，指向新创建的对象（新对象也就有了构造函数的所有属性）</span></span><br><span class="line">    func.<span class="title function_">apply</span>(obj, rest)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  <span class="keyword">let</span> constructor = [].<span class="property">shift</span>.<span class="title function_">apply</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  obj.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="keyword">let</span> result = constructor.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="promise"></a></p><h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESOLVED</span> = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line">  that.<span class="property">state</span> = <span class="variable constant_">PENDING</span> <span class="comment">//一开始 Promise 的状态应该是 pending</span></span><br><span class="line">  that.<span class="property">value</span> = <span class="literal">null</span> <span class="comment">//保存 resolve 或者 reject 中传入的值</span></span><br><span class="line"><span class="comment">//resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，</span></span><br><span class="line"><span class="comment">//因为当执行完 Promise 时状态可能还是等待中，</span></span><br><span class="line"><span class="comment">//这时候应该把 then 中的回调保存起来用于状态改变时使用</span></span><br><span class="line">  that.<span class="property">resolvedCallbacks</span> = []</span><br><span class="line">  that.<span class="property">rejectedCallbacks</span> = []</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;999&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123; <span class="comment">//判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态</span></span><br><span class="line">      that.<span class="property">state</span> = <span class="variable constant_">RESOLVED</span> <span class="comment">//将当前状态更改为对应状态</span></span><br><span class="line">      that.<span class="property">value</span> = value <span class="comment">// 并且将传入的值赋值给 value</span></span><br><span class="line">      that.<span class="property">resolvedCallbacks</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">value</span>)) <span class="comment">// 遍历回调数组并执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (that.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      that.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">      that.<span class="property">value</span> = value</span><br><span class="line">      that.<span class="property">rejectedCallbacks</span>.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(that.<span class="property">value</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;000&#x27;</span>);</span><br><span class="line">    <span class="title function_">fn</span>(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) &#123; <span class="comment">// 较为复杂的 then 函数</span></span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line"><span class="comment">// 判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line"><span class="comment">// 当参数不是函数类型时，需要创建一个函数赋值给对应的参数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> r</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 状态是等待态的话，就往回调函数中 push 函数</span></span><br><span class="line">  <span class="keyword">if</span> (that.<span class="property">state</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">    that.<span class="property">resolvedCallbacks</span>.<span class="title function_">push</span>(onFulfilled)</span><br><span class="line">    that.<span class="property">rejectedCallbacks</span>.<span class="title function_">push</span>(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 当状态不是等待态时，就去执行相对应的函数</span></span><br><span class="line">  <span class="keyword">if</span> (that.<span class="property">state</span> === <span class="variable constant_">RESOLVED</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;333&#x27;</span>)</span><br><span class="line">    <span class="title function_">onFulfilled</span>(that.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.<span class="property">state</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;444&#x27;</span>)</span><br><span class="line">    <span class="title function_">onRejected</span>(that.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 进入等待态的逻辑</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">//pending状态</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// resolve(1)</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
